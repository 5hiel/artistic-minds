/**
 * Transformation Puzzles Tests
 * 
 * Tests for the Non-Verbal Transformation puzzle generator, covering:
 * - Static puzzle validation
 * - Dynamic puzzle generation with all transformation types
 * - 3x3 grid pattern validation
 * - Multi-property shape transformations
 * - Option generation and answer correctness
 * - Missing position handling
 */

import { 
  TransformationPuzzleGenerator, 
  transformationPuzzleGenerator,
  TransformationType,
  TransformationDirection,
  TransformationShape,
  TransformationSize,
  TransformationColor,
  TransformationFill,
  TransformationRotation
} from '../../lib/puzzles/reasoning/transformation';
import { PuzzleValidator } from '@/lib/core/basePuzzle';

describe('TransformationPuzzleGenerator', () => {
  let generator: TransformationPuzzleGenerator;

  beforeEach(() => {
    generator = new TransformationPuzzleGenerator();
    generator.resetRotation();
  });

  describe('Static Puzzles', () => {
    test('should have 5 static transformation puzzles', () => {
      expect(generator.getStaticCount()).toBe(5);
      expect(generator.staticPuzzles).toHaveLength(5);
    });

    test('all static puzzles should be valid', () => {
      generator.staticPuzzles.forEach((puzzle, index) => {
        expect(PuzzleValidator.validatePuzzle(puzzle)).toBe(true);
        expect(puzzle.question).toMatch(/(transformation|completes).*pattern/);
        expect(puzzle.options).toHaveLength(4);
        expect(puzzle.correctAnswerIndex).toBeGreaterThanOrEqual(0);
        expect(puzzle.correctAnswerIndex).toBeLessThan(4);
        expect(puzzle.explanation).toBeTruthy();
        expect(puzzle.grid).toHaveLength(3);
        puzzle.grid.forEach(row => expect(row).toHaveLength(3));
        expect(puzzle.missingPosition).toHaveProperty('row');
        expect(puzzle.missingPosition).toHaveProperty('col');
        expect(puzzle.missingPosition.row).toBeGreaterThanOrEqual(0);
        expect(puzzle.missingPosition.row).toBeLessThan(3);
        expect(puzzle.missingPosition.col).toBeGreaterThanOrEqual(0);
        expect(puzzle.missingPosition.col).toBeLessThan(3);
        expect(puzzle.transformationType).toMatch(/^(rotation|size|color|fill|substitution)$/);
        expect(puzzle.transformationDirection).toMatch(/^(horizontal|vertical)$/);
        expect(puzzle.rule).toBeTruthy();
      });
    });

    test('should validate transformation types in static puzzles', () => {
      const transformationTypes = generator.staticPuzzles.map(p => p.transformationType);
      const uniqueTypes = new Set(transformationTypes);
      
      expect(uniqueTypes.has(TransformationType.ROTATION)).toBe(true);
      expect(uniqueTypes.has(TransformationType.SIZE_CHANGE)).toBe(true);
      expect(uniqueTypes.has(TransformationType.SHAPE_SUBSTITUTION)).toBe(true);
      expect(uniqueTypes.has(TransformationType.FILL_CHANGE)).toBe(true);
      expect(uniqueTypes.size).toBeGreaterThanOrEqual(4);
    });

    test('should have correct grid structure with missing element', () => {
      generator.staticPuzzles.forEach(puzzle => {
        let nullCount = 0;
        let elementCount = 0;
        
        puzzle.grid.forEach((row, rowIndex) => {
          row.forEach((element, colIndex) => {
            if (element === null) {
              nullCount++;
              expect(rowIndex).toBe(puzzle.missingPosition.row);
              expect(colIndex).toBe(puzzle.missingPosition.col);
            } else {
              elementCount++;
              expect(element).toHaveProperty('shape');
              expect(element).toHaveProperty('size');
              expect(element).toHaveProperty('color');
              expect(element).toHaveProperty('fill');
              expect(element).toHaveProperty('rotation');
              expect(Object.values(TransformationShape)).toContain(element.shape);
              expect(Object.values(TransformationSize)).toContain(element.size);
              expect(Object.values(TransformationColor)).toContain(element.color);
              expect(Object.values(TransformationFill)).toContain(element.fill);
              expect(Object.values(TransformationRotation)).toContain(element.rotation);
            }
          });
        });
        
        expect(nullCount).toBe(1);
        expect(elementCount).toBe(8);
      });
    });
  });

  describe('Dynamic Puzzle Generation', () => {
    test('should generate valid dynamic transformation puzzles', () => {
      for (let i = 0; i < 20; i++) {
        const puzzle = generator.getRandom();
        expect(PuzzleValidator.validatePuzzle(puzzle)).toBe(true);
        expect(puzzle.question).toMatch(/(transformation|completes).*pattern/);
        expect(puzzle.options).toHaveLength(4);
        expect(puzzle.grid).toHaveLength(3);
        puzzle.grid.forEach(row => expect(row).toHaveLength(3));
        expect(puzzle.transformationType).toMatch(/^(rotation|size|color|fill|substitution)$/);
        expect(puzzle.transformationDirection).toMatch(/^(horizontal|vertical)$/);
        expect(puzzle.rule).toBeTruthy();
        expect(puzzle.explanation).toBeTruthy();
      }
    });

    test('should generate different transformation types', () => {
      const puzzles = [];
      for (let i = 0; i < 50; i++) {
        puzzles.push(generator.getRandom());
      }
      
      const transformationTypes = puzzles.map(p => p.transformationType);
      const uniqueTypes = new Set(transformationTypes);
      
      expect(uniqueTypes.size).toBeGreaterThanOrEqual(2);
      expect(uniqueTypes.has(TransformationType.ROTATION) || 
             uniqueTypes.has(TransformationType.SIZE_CHANGE) || 
             uniqueTypes.has(TransformationType.FILL_CHANGE) ||
             uniqueTypes.has(TransformationType.SHAPE_SUBSTITUTION)).toBe(true);
    });

    test('should generate puzzles with missing elements in different positions', () => {
      const puzzles = [];
      for (let i = 0; i < 30; i++) {
        puzzles.push(generator.getRandom());
      }
      
      const positions = puzzles.map(p => `${p.missingPosition.row}-${p.missingPosition.col}`);
      const uniquePositions = new Set(positions);
      
      expect(uniquePositions.size).toBeGreaterThan(1); // Should have variety in missing positions
    });

    test('should generate mathematically consistent patterns', () => {
      for (let i = 0; i < 10; i++) {
        const puzzle = generator.getRandom();
        
        // Verify grid has exactly one null element
        let nullCount = 0;
        puzzle.grid.forEach(row => {
          row.forEach(element => {
            if (element === null) nullCount++;
          });
        });
        expect(nullCount).toBe(1);
        
        // Verify null element is at the specified missing position
        expect(puzzle.grid[puzzle.missingPosition.row][puzzle.missingPosition.col]).toBeNull();
      }
    });

    test('should generate unique options for each puzzle', () => {
      for (let i = 0; i < 10; i++) {
        const puzzle = generator.getRandom();
        const uniqueOptions = new Set(puzzle.options);
        expect(uniqueOptions.size).toBe(4);
      }
    });
  });

  describe('Puzzle Rotation', () => {
    test('getNext should rotate through static puzzles', () => {
      const firstPuzzle = generator.getNext();
      const secondPuzzle = generator.getNext();
      
      expect(firstPuzzle).not.toEqual(secondPuzzle);
      expect(firstPuzzle.transformationType).toBe(TransformationType.ROTATION);
    });

    test('should cycle back to beginning after all puzzles', () => {
      const puzzleCount = generator.getStaticCount();
      
      // Get all puzzles
      const puzzles = [];
      for (let i = 0; i < puzzleCount; i++) {
        puzzles.push(generator.getNext());
      }
      
      // Next puzzle should be the first one again
      const cyclePuzzle = generator.getNext();
      expect(cyclePuzzle.transformationType).toBe(puzzles[0].transformationType);
    });

    test('resetRotation should reset to first puzzle', () => {
      // Advance rotation
      generator.getNext();
      generator.getNext();
      
      // Reset
      generator.resetRotation();
      
      // Should be back to first puzzle
      const puzzle = generator.getNext();
      expect(puzzle.transformationType).toBe(TransformationType.ROTATION);
    });
  });

  describe('Transformation Types', () => {
    test('should handle rotation transformations correctly', () => {
      const rotationPuzzles = generator.staticPuzzles.filter(p => p.transformationType === TransformationType.ROTATION);
      expect(rotationPuzzles.length).toBeGreaterThan(0);
      
      rotationPuzzles.forEach(puzzle => {
        expect(puzzle.explanation.toLowerCase()).toContain('rotat');
        expect(puzzle.rule.toLowerCase()).toContain('rotat');
      });
    });

    test('should handle size transformations correctly', () => {
      const sizePuzzles = generator.staticPuzzles.filter(p => p.transformationType === TransformationType.SIZE_CHANGE);
      expect(sizePuzzles.length).toBeGreaterThan(0);
      
      sizePuzzles.forEach(puzzle => {
        expect(puzzle.explanation.toLowerCase()).toMatch(/(size|grow)/);
        expect(puzzle.rule.toLowerCase()).toMatch(/(size|grow)/);
      });
    });

    test('should handle fill transformations correctly', () => {
      const fillPuzzles = generator.staticPuzzles.filter(p => p.transformationType === TransformationType.FILL_CHANGE);
      expect(fillPuzzles.length).toBeGreaterThan(0);
      
      fillPuzzles.forEach(puzzle => {
        expect(puzzle.explanation.toLowerCase()).toContain('fill');
        expect(puzzle.rule.toLowerCase()).toContain('fill');
      });
    });

    test('should handle shape substitution transformations correctly', () => {
      const substitutionPuzzles = generator.staticPuzzles.filter(p => p.transformationType === TransformationType.SHAPE_SUBSTITUTION);
      expect(substitutionPuzzles.length).toBeGreaterThan(0);
      
      substitutionPuzzles.forEach(puzzle => {
        expect(puzzle.explanation.toLowerCase()).toMatch(/(sequence|pattern)/);
        expect(puzzle.rule.toLowerCase()).toMatch(/(square|circle|triangle)/);
      });
    });
  });

  describe('Explanations and Rules', () => {
    test('should generate clear explanations for all puzzles', () => {
      for (let i = 0; i < 10; i++) {
        const puzzle = generator.getRandom();
        const explanation = puzzle.explanation;
        
        expect(explanation).toBeTruthy();
        expect(explanation).toMatch(/(pattern|transformation|row|column)/i);
        expect(explanation.length).toBeGreaterThan(20); // Should be descriptive
      }
    });

    test('static puzzle explanations should match their transformation types', () => {
      generator.staticPuzzles.forEach(puzzle => {
        const explanation = puzzle.explanation.toLowerCase();
        const transformationType = puzzle.transformationType;
        
        if (transformationType === TransformationType.ROTATION) {
          expect(explanation).toContain('rotat');
        } else if (transformationType === TransformationType.SIZE_CHANGE) {
          expect(explanation).toMatch(/(size|grow)/);
        } else if (transformationType === TransformationType.FILL_CHANGE) {
          expect(explanation).toContain('fill');
        } else if (transformationType === TransformationType.SHAPE_SUBSTITUTION) {
          expect(explanation).toMatch(/(sequence|pattern)/);
        }
      });
    });

    test('should generate appropriate rules for transformation types', () => {
      for (let i = 0; i < 10; i++) {
        const puzzle = generator.getRandom();
        const rule = puzzle.rule.toLowerCase();
        const transformationType = puzzle.transformationType;
        
        expect(rule).toBeTruthy();
        expect(rule.length).toBeGreaterThan(10);
        
        if (transformationType === TransformationType.ROTATION) {
          expect(rule).toContain('rotat');
        } else if (transformationType === TransformationType.SIZE_CHANGE) {
          expect(rule).toContain('size');
        } else if (transformationType === TransformationType.FILL_CHANGE) {
          expect(rule).toContain('fill');
        }
      }
    });
  });

  describe('Error Handling', () => {
    test('should handle edge cases in dynamic generation', () => {
      // Test multiple times to catch any edge cases
      for (let i = 0; i < 50; i++) {
        const puzzle = generator.getRandom();
        
        // Ensure valid grid structure
        expect(puzzle.grid).toHaveLength(3);
        puzzle.grid.forEach((row, rowIndex) => {
          expect(row).toHaveLength(3);
          row.forEach((element, colIndex) => {
            if (rowIndex === puzzle.missingPosition.row && colIndex === puzzle.missingPosition.col) {
              expect(element).toBeNull();
            } else {
              expect(element).not.toBeNull();
              expect(element).toHaveProperty('shape');
              expect(element).toHaveProperty('size');
              expect(element).toHaveProperty('color');
              expect(element).toHaveProperty('fill');
              expect(element).toHaveProperty('rotation');
            }
          });
        });
      }
    });

    test('should ensure answer options are unique and valid', () => {
      for (let i = 0; i < 20; i++) {
        const puzzle = generator.getRandom();
        const uniqueOptions = new Set(puzzle.options);
        expect(uniqueOptions.size).toBe(4);
        
        puzzle.options.forEach(option => {
          expect(typeof option).toBe('string');
          expect(option.length).toBeGreaterThan(0);
        });
      }
    });
  });

  describe('Legacy Functions', () => {
    test('getNextTransformationPuzzle should work and include legacy fields', () => {
      const { getNextTransformationPuzzle } = require('@/lib/transformationPuzzles');
      const puzzle = getNextTransformationPuzzle();
      
      expect(puzzle).toHaveProperty('type', 'transformation');
      expect(puzzle).toHaveProperty('correctAnswer');
      expect(puzzle.correctAnswer).toBe(puzzle.options[puzzle.correctAnswerIndex]);
    });

    test('generateRandomTransformationPuzzle should work and include legacy fields', () => {
      const { generateRandomTransformationPuzzle } = require('@/lib/transformationPuzzles');
      const puzzle = generateRandomTransformationPuzzle();
      
      expect(puzzle).toHaveProperty('type', 'transformation');
      expect(puzzle).toHaveProperty('correctAnswer');
      expect(puzzle.correctAnswer).toBe(puzzle.options[puzzle.correctAnswerIndex]);
    });
  });

  describe('Singleton Instance', () => {
    test('should export singleton instance', () => {
      expect(transformationPuzzleGenerator).toBeInstanceOf(TransformationPuzzleGenerator);
      expect(transformationPuzzleGenerator.getStaticCount()).toBe(5);
    });

    test('singleton should maintain state', () => {
      const firstPuzzle = transformationPuzzleGenerator.getNext();
      const secondPuzzle = transformationPuzzleGenerator.getNext();
      
      expect(firstPuzzle).not.toEqual(secondPuzzle);
    });
  });
});

describe('Transformation Integration', () => {
  test('should integrate with BasePuzzle validation', () => {
    const puzzle = transformationPuzzleGenerator.getNext();
    expect(PuzzleValidator.validatePuzzle(puzzle)).toBe(true);
  });

  test('should have consistent interface with other puzzle types', () => {
    const puzzle = transformationPuzzleGenerator.getRandom();
    
    // Should have all BasePuzzle properties
    expect(puzzle).toHaveProperty('question');
    expect(puzzle).toHaveProperty('options');
    expect(puzzle).toHaveProperty('correctAnswerIndex');
    expect(puzzle).toHaveProperty('explanation');
    
    // Should have TransformationPuzzle specific properties
    expect(puzzle).toHaveProperty('grid');
    expect(puzzle).toHaveProperty('missingPosition');
    expect(puzzle).toHaveProperty('transformationType');
    expect(puzzle).toHaveProperty('transformationDirection');
    expect(puzzle).toHaveProperty('rule');
  });

  test('should support all transformation types for comprehensive coverage', () => {
    const puzzles = [];
    for (let i = 0; i < 100; i++) {
      puzzles.push(transformationPuzzleGenerator.getRandom());
    }
    
    const transformationTypes = puzzles.map(p => p.transformationType);
    const uniqueTypes = new Set(transformationTypes);
    
    // Should generate multiple different transformation types
    expect(uniqueTypes.size).toBeGreaterThanOrEqual(3);
  });

  test('should support both horizontal and vertical transformation directions', () => {
    const puzzles = [];
    for (let i = 0; i < 50; i++) {
      puzzles.push(transformationPuzzleGenerator.getRandom());
    }
    
    const directions = puzzles.map(p => p.transformationDirection);
    const uniqueDirections = new Set(directions);
    
    // Should support both transformation directions  
    expect(uniqueDirections.has(TransformationDirection.HORIZONTAL)).toBe(true);
    // Note: Currently only horizontal is implemented in templates, but structure supports vertical
  });
});